## TableView

### 1. UITableViewController

- 표면적 역할은 목록 형태의 콘텐츠를 화면에 표현해주는 것
- 계층 구조를 이루는 콘텐츠의 상위 카테고리를 정렬해 표현함으로써 방대한 콘텐츠 속에서도 사용자가 원하는 항목을 쉽게 접근할 수 있게 함
- 테이블 뷰 컨트롤러와 내비게이션 컨트롤러는 계층적 성격의 콘텐츠를 표현해주기 위해 상호 보완적인 역할을 함
  - 테이블 뷰 컨트롤러를 이용하여 수평적 관계의 카테고리나 콘텐츠를 병렬로 배열하고, 수직적 관계로 세분한 정보들을 내비게이션 컨트롤러를 통하여 직렬로 표현하여 전체적인 앱의 콘텐츠 표현 구조를 구성
- 루트 뷰 컨트롤러가 테이블 뷰

참고 : https://developer.apple.com/documentation/uikit/uitableviewdelegate

**[UITableViewDelegate ]**

Methods for managing selections, configuring section headers and footers, deleting and reordering cells, and performing other actions in a table view.

- Create and manage custom header and footer views.
- Specify custom heights for rows, headers, and footers.
- Provide height estimates for better scrolling support.
- Indent row content.
- Respond to row selections.
- Respond to swipes and other actions in table rows.
- Support editing the table's content.



**[UITableViewDataSource]**

The methods adopted by the object you use to manage data and provide cells for a table view.

- Reporting the number of sections and rows in the table.
- Providing cells for each row of the table.
- Providing titles for section headers and footers.
- Configuring the table's index, if any.
- Responding to user- or table-initiated updates that require changes to the underlying data.

```swift
// Return the number of rows for the table.     
override func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -> Int {
   return 0
}

// Provide a cell object for each row.
override func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -> UITableViewCell {
   // Fetch a cell of the appropriate type.
   let cell = tableView.dequeueReusableCell(withIdentifier: "cellTypeIdentifier", for: indexPath)
   
   // Configure the cell’s contents.
   cell.textLabel!.text = "Cell text"
       
   return cell
}
```

### Specifying the Location of Rows and Sections

Table views communicate the location of cells to you using the [`row`](https://developer.apple.com/documentation/foundation/nsindexpath/1614853-row) and [`section`](https://developer.apple.com/documentation/foundation/nsindexpath/1528298-section) properties of [`NSIndexPath`](https://developer.apple.com/documentation/foundation/nsindexpath) objects. Row and section indexes are zero based, so the first section is at index `0`, the second at index `1`, and so on. Similarly, the first row of each section is at index `0`, which means you need both the `section` and `row` values to identify a row uniquely. If your table has no sections, you need only the `row` value.

- 섹션 : 테이블 뷰 내에서 셀들을 그룹으로 묶을 수 있는 단위 



### 2. Cell

#### 2-1) 프로토타입 셀

- 테이블 뷰의 셀을 원하는 대로 쉽게 디자인할 수 있도록 해주는 객체
- 앱이 실행되는 모바일 디바이스에 따라 가로 너비가 달라질 경우 테이블 뷰의 길이도 적절히 변경되어야 하는데, 이때 Accessroy View 영역은 너비가 고정값을 유지하는 반면 Cell Content 영역은 가변적인 너비값으로 처리됩니다. 화면이 넓어지면 더 넓게, 화면이 좁아지면 좁게 처리된다는 뜻이죠. 따라서 Cell Content 영역에 콘텐츠를 배치할 때는 기기에 따른 가로 길이의 변화에도 신경 써야 합니다. 
- 자동으로 이미지나 텍스트 콘텐츠를 삽입할 수 있는 속성이 제공되므로 우리가 할 일은 단순합니다.
- Table View Cell -> Style : 테이블 뷰 셀에 출력되는 항목과 형식을 결정
  - Basic : 기본 타이틀만 출력
  - Right Detail : 셀의 오른쪽 끝에 출력
  - Left Detail : 셀의 왼쪽 끝에 출력
  - Subtitle : 기본 타이틀의 아래에 출력

<img src = "../image\04\04.png" width="700">

- 프로토타입 셀은 아울렛 변수를 연결하지 않고 아이디를 부여합니다. 이는 프로토타입 셀이 실제로 화면에 표시되는 컨트롤이 아니기 때문입니다. 버튼이나 텍스트 레이블과 달리 프로토타입 셀이 직접 데이터를 표시하거나 화면의 공간을 차지하지는 않습니다. 그저 테이블 뷰가 화면에 표현딜 때 어떤 식으로 구성될 것인지를 미리 보여주기 위한 가상 틀에 불과합니다.
- 따라서 프로토타입 셀을 이용하여 화면을 구현할 때는 프로토타입 셀 자체에 콘텐츠를 올려서 푷녀하는 것이 아니라 프로토타입 셀이라는 틀을 바탕으로 하여 실제로 사용할 셀을 목록의 개수만큼 생성하고, 각각에 데이터를 바인딩하는 과정을 거쳐 목록 화면을 구현합니다.
- 아이디를 이용해서 프로토타입 셀을 참조한느 또 다른 이유는 하나의 테이블 뷰에 하나 이상의 프로토타입 셀을 사용할 수 있기 때문입니다. 원하는 만큼 틀을 여러 개 만들 수 있다는 뜻이죠. 서로 다른 형식으로 만들어진 여러 개의 프로토타입 셀을 구분하기 위해서 우리는 아이디를 부여합니다.
- 프로토타입 셀을 하나 이상 사용할 수 있다는 것은 다음과 같은 이점이 있습ㄴ다. 예를 들어, 조건에 따라 두 가지 이상의 셀 디자인이 필요한 경우 소스 코드에서 직접 화면 구성과 컨트롤 배치 등을 변경할 수도 있겠지만, 그보다는 서로 다른 형식을 가지는 프로토타입 셀 여러 개를 설계해 두고, 조건에 맞는 프로토타입 셀을 호출하기만 하면 화면 구성은 더 이상 신경 쓸 필요가 없습니다.

Accessory 속성 :셀의 오른쪽 끝에 표시될 아이콘을 선택하는 데에 사용 - 4개의 표준 타입 아이콘이 있음

- Disclosure Indicatore : 티으블 뷰 셀을 선택했을 때 데이터 구조상 하위 레벨에 해당하는 또 다른 테이블 뷰 화면을 보여주게 됨을 의미
- Detail Disclosure Button : Detail 옵션과 Disclosure Indicator 옵션이 합쳐진 것. 즉, 테이블 뷰 셀을 선택했을 때 그에 대한 상세 내용을 보여주게 됨을 의미하지만, 상세 내용은 Disclosure Indicator와 같이 하위 베레의 테이블 뷰가 될 수도, Detail과 같이 일반 뷰에 표현된 상세 내용이 될 수도 있음
- Checkmart : 테이블 뷰 아이템의 개별 행을 사용자가 선택했다는 것을 나타냄. 이런 종류의 테이블 뷰는 대개 선택 목록이라고 불리며, 또 다른 선택용 목록인 팝업 목록과 비슷. 선택용 목록은 하나만 선택하도록 제한하거나 여러 개를 선택할 수 있도록 허용할 수도 있음
- Detail : 테이블 뷰 셀을 선택했을 때 이에 대한 상세 내용을 일반 뷰로 보여주게 됨을 의미

#### 2-2) 커스텀클래스로 프로토타입 셀 객체 제어하기

- 프로토타입 셀 자체를 커스텀 클래스와 연결한 다음, 셀 위에 올려진 객체를 아울렛 변수로 연결해서 참조
- 아울렛 변수를 뷰 컨트롤러에 직접 정의하면 셀 내부 객체들이 정적인 객체가 되므로 사용하는 데에 문제가 생기지만, 프로토타입 셀을 연결한 커스텀 클래스에 아울렛 변수를 정의하면 이는 동적으로 사용할 수 있는 형태의 객체가 되기 때문에 아울렛 변수를 통해 객체를 관리할 수 있습니다. 따라서 태그 속성 사용 시 단점으로 꼽히는 객체 관리 문제나 잘못된 태그값을 호출하는 문제로부터 자유로워질 수 있으며, 유지 보수도 무척 편리해짐
- [uiimage]
- 앱이 이미지를 읽어 들일 때는 파일 시스템을 통해 이미지 파일을 열고 데이터를 읽어야 하므로 I/O가 발생합니다. 이미지 파일을 읽을 때마다 발생하는 I/O는 성능에 큰 영향을 끼치죠. 그래서 이를 해결하기 위한 여러 가지 방법이 고안되었는데, 그중의 하나가 바로 캐싱입니다. UiImage(named:) 방식으로 생성한 이미지 객체는 한 번 읽어온 이미지를 메모리에 저장해둔 다음 두 번째 호출부터는 메모리에 저장된 이미지를 가져옵니다.
- 주의할 점은 이렇게 저장된 메모리는 이미지 객체를 다 사용한 후에도 잘 해제되지 않는다는 것입니다. 자주 쓰는 이미지라면 관계없지만 만약 용량이 크고 한 번만 사용하는 이미지를 이 방식으로 읽어 들이면 메모리 관리에 빨간 불이 켜질 수도 있습니다. 앱에서 이미지 뷰어 등을 구현해야 할 때가 대표적으로 한 번만 이미지를 사용하는 경우죠

- 이미지 객체로 인한 메모리 점유가 걱정되는 경우에는 UIImage(contentsOfFile:) 생성자를 사용해서 이미지 객체를 생성하는 것이 좋습니다. 이 생성자를 사용하여 생성되는 이미지 객체는 캐싱되지 않는 특징이 있습니다. 이미지 데이터를 매번 다시 읽어와야 하므로 앞의 방식보다는 성능이 약간 저하될 수 있겠지만, 자주 호출되는 이미지가 아니라면 이 바식을 사용하는 것이 메모리 관리 면에서 효율적입니다.
- 우리가 테이블 뷰에 추가한 이미지 뷰는 자주 호출되는 이미지에 해당합니다. 아직 배우지는 않았지만 테이블 뷰의 메커니즘 때문에 이미지를 다시 읽어 들여야 할 경우가 빈번하게 발생합니다. 이때에는 가급적 I/O를 줄이는 것이 메모리 관리 이슈보다 더 중요하므로 우리는 이미지 캐싱을 지원하는 UIImage(named:) 구문을 사용하도록 하겠습니다.



### 3. 데이터 소스

- 테이블 뷰를 정적 타입으로 바꾸면 기존의 프로토타입 셀은 사라지고 그 자리를 정적인 형식의 셀이 채우게 됨. 이 셀들은 프로토타입 셀과 달리 화면에 직접 표현되므로 우리가 필요한 콘텐츠를 직접 올려서 구현할 수 있음

[데이터 소스 만들기]

- 클래스는 영화 정보를 담기 위한 **객체**, 정의된 **프로퍼티**만 봐도 알 수 있음

- 우리는 이들 변수 각각에 값을 저장하지만, 전달할 때는 클래스의 인스턴스 자체를 전달하게 됩니다. 값을 주고받을 때 개발 변수가 아니라 클래스 인스턴스 자체가 전달되므로 각 변수에 저장된 값들의 관련성이 유지될 수 있음은 물론, 여러 개의 변수가 필요하지도 않습니다. 이렇게 만들어진 클래스 인스턴스는 테이블 뷰의 셀 하나하나를 구성하는 데이터 소스로 사용됩니다. 각각의 프로퍼티는 비어있을 수도 있으므로 옵셔널 타입으로 선언됩니다. p.509

  >[Value Object 패턴, VO]
  >
  >데이터 저장을 전담하는 클래스를 별도로 분리하는 설계 방식을 지칭하며, 객체지향 설계에서는 매우 자주 사용
  >
  >보통 데이터 저장을 위한 클래스임을 쉽게 식별할 수 있게 하려고 클래스의 마지막에 VO라는 접미사를 붙임
  >
  >밥그릇, 국그릇, 반찬그릇을 담은 식판이라고 생각 -> 식판으로 한번에 이동 가능

- 리펙토링 p.516

- 데이터 소스와 테이블 뷰를 연동하는 과정은 UITableViewDataSource라는 프로토콜에 의존하여 이루어집니다. 테이블 뷰 컨트롤러는 이 프로토콜을 참고하여 지정된 메소드를 호출함으로써 데이터 소스와 테이블 뷰를 연동합니다. 원래 대로라면 이 프로토콜을 상속받아야 하지만, 우리가 상속받고 있는 UITableViewController 클래스가 이미 해당 프로토콜을 상속받고 있으므로 다시금 상속받을 필요는 없습니다.

- 테이블 뷰에 데이터 소스를 연동할 때 필요한 내용은 다음 두 가지

  - 테이블이 몇 개의 행으로 구성되는가?
  - 각 행의 내용은 어떻게 구성되는가?

[ 데이터 소스 연동을 위한 핵심 메소드 ]

이들 메소드는 이미 UItableView 클래스에 구현되어 있습니다. 따라서 여러분이 커스텀 클래스에서 이들 메소드를 작성한다면 이는 오버라이드가 됩니다.

- tableView(_:numberOfRowsInSection:)

  - 테이블 뷰가 생성해야 할 행(row)의 개수를 반환합니다. 이 메소드는 iOS 시스템이 테이블 뷰를 구성하기 위해 먼저 호출하는 메소드입니다. 이 메소드는 우리가 사용하기 위한 것이 아니라 시스템이 사용하기 위한 메소드라는 것입니다. 다시 말해, 현재 몇개의 행이 구성되어 있는지를 우리에게 알려주는 역할이 아니라 몇 개의 행을 생성해야 할지 우리가  iOS 시스템에게 알려주기 위해 작성하는 메소드입니다.델리게이트에서 읽어 들이기 위한 용도
  - iOS에서 테이블 뷰를 구성할 때는 지정해 주는 개수만큼 행이 만들어짐
  - iOS가 이 메소드를 호출할 때는 두 개의 인자값을 함께 전달 첫 번째는 테이블 뷰 객체 정보이며, 두 번째는 섹션 정보
  - 첫 번째 인자값은 이 메소드를 호출한 테이블 뷰 객체에 대한 정보를 나타냅니다. 하나의 뷰 컨트롤러 내에 두 개 이상의 테이블 뷰가 존재할 수 있지만, iOS의 프로토콜 기반 설계 방식의 특성으로 인하여 개별 테이블 뷰 각각에 대한 메소드를 구분해서 작성하기란 어렵습니다. 따라서 테입르 뷰가 여러 개일 때에도 모두 같은 메소드를 호출하게 됩니다. 이때, 호출되는 메소드 이방에서는 어느 테이블 뷰에서 자신을 호출하는지를 알 필요가 있기 때문에, 이를 위해 첫 번째 인자값이 사용됩니다. 
  - 두번째 인자값은 섹션에 대한 정보입니다. 테이블 뷰는 일조의 행 그룹의 개념인 섹션으로 이루어질 수 있고, 그 하위에 개별 행이 추가됩니다. 섹션별로 행의 수를 다르게 구성할 수 있기 때문에 섹션에 따라 구분하여 행의 개수를 반환해야 할 때도 있습니다. 따라서 섹션에 대한 정보도 함께 요구됩니다. 필요에 따라서는 테이블 뷰 정보와 섹션 정보를 바탕으로 반환값을 다르게 줄 수도 있습니다. 이 테이블 뷰의 이 섹션은 몇 개의 행을 가져야 하고, 저 테이블 뷰의 섹션은 몇 개의 행을 가져야 한다는 식
  - 메소드 호출 시 함께 전달되는 두 개의 매개변수 tableView와 Section은 각각 어느 테이블 뷰인지, 그리고 테이블 뷰 내에서도 몇 번째 섹션에 대한 호출인지를 알려줍니다.

- tableView(_:cellForRowAt:)

  - 각 행이 화면에 표현해야 할 내용을 구성하는 데에 사용

  - 하지만 이 메소드가 반환하는 값은 전체 테이블 뷰의 목록이 아니라 하나하나의 개별적인 테이블 셀 객체인데, 이는 화면에 표현해야 할 목록의 수만큼 이 메소드가 반복적으로 호출된다는 것을 의미합니다. 메소드 내에서 테이블 뷰 셀 객체를 구성한 다음 결과값으로 반환하면 시스템은 이 객체를 받아 테이블 뷰의 목록 각 행에 채워 넣는 방식입니다. 우리가 작성한 데이터 소스는 이 메소드 내부에서 활용되어 특정 행의 콘텐츠를 구성하는 데에 사용됩니다.

  - 이 메소드는 개별 행을 만들어내는 역할을 합니다. 앞의 메소드가 반환하는 값만큼 이 메소드가 반복 호출됩니다. 이 메소드가 한 번 호출될 때마다 하나의 행이 만들어진다고 생각하면 됩니다. 몇 번째 행을 구성해야 하는지 알려주기 위해 IndexPath 타입의 객체가 인자값으로 전달됩니다. 행 번호를 알고자 할 때에는 indexPath.row 속성을 사용하면 됩니다.

  - 이 속성은 배열과 마찬가지로 0부터 시작합니다. 첫 번째 행이면 0을, 두 번째 행이면 1을 반환하는 식입니다. 이렇게 0부터 시작되는 행 번호는 배열의 인덱스와 일치하기 때문에 +1 또는 -1 할 필요 없이 배열 형식의 데이터 소스의 인덱스로 바로 사용할 수 있음 

  - 위 메소드에서 가장 먼저 처리하고 있는 것은 이 속성을 사용하여 배열로부터 뎅터 소스를 읽어오는 것

  - dequeueReusableCellWithIdentifier:  메소드는 인자값으로 입력받은 아이디를 이용하여 스토리보드에 정의된 프로토타입 셀을 찾고, 이를 인스턴스로 생성하여 우리에게 제공합니다. 우리가 앞서 스토리보드의 프로토타입 셀에 설정해 주었던 Identifier 속성이 이 과정에서 프로토타입 셀을 식별하기 위해 사용됩니다.

  - 이 과정에 재사용 큐(Reusable Queue)라는 객체가 관여합니다. 테이블 뷰 객체가 제공하는 

    



- iOS 시스템은 테이블 뷰를 구성하기 위해 먼저 1번 메소드를 호출하여 몇 개의 행을 생성해야 하는지를 반환하고, 그 수만큼 2번 메소드를 호출합니다. 매 호출 시마다 몇 번째 행에 대한 요청인지를 함께 전달하기 때문에 우리는 이 값을 받아 해당 행에 적절한 콘텐츠를 구성한 다음 이를 테이블 뷰 셀 객체 형태로 리턴하면 됩니다. 이 케소드는 한 번 호출할 때마다 하나의 테이블 뷰 셀을 반환하므로 열 개의 행을 가진 목록을 구성하려면 모두 열 번의 호출이 필요합니다

  ```swift
  func tableView(_ tableView: UITableView, 
    cellForRowAt indexPath: IndexPath) -> UITableViewCell
  ```

  - iOS 시스템은 이번에도 두 개의 인자값을 사용하여 이 메소드를 호출합니다. 하지만 내용은 조금 다릅니다. 하나는 구성할 테이블 뷰 객체에 대한 참조이고, 또 다른 하나는 구성할 행에 대한 참조 정보입니다. 하나의 뷰 컨트롤러 안에 두 개 이상의 테이블 뷰가 사용될 경우, 첫 번째 인자값으로 전달된 tableView 매개변수를 사용하면 어느 테이블 뷰에 대한 요청인지 쉽게 구분할 수 있습니다. 단순히 구분 용도만이 아니라 테이블 뷰 자체에 대한 참조가 필요할 때에도 사용할 수 있습니다.
    - 첫 번째 매개변수를 통해 테이블 뷰가 특정되면, 이번에는 두 번째 매개변수인 indexPath를 통해 몇 번째 행을 구성하기 위한 호출인지를 구분할 수 있습니다. IndexPath  객체 타입으로 정의도니 이 매개변수는 선택된 행에 대한 관련 속성들을 모두 제공합니다. 그중에서도 .row는 가장 많이 사용되는 속성으로, 행의 번호를 알려주는 역할을 합니다. 0부터 시작하는 이 행 번호는 배열로 이루어진 데이터 소스의 아이템 인덱스와 대부분의 경우 일치하므로 이 속성을 사용하면 데이터 소스의 필요한 부분을 편리하게 읽어 들일 수 있습니다.

[ 사용자의 액션 처리를 위한 핵심 메소드 ]

- tableView(_:didSelectRowAt:)

- 사용자가 목록 중에서 특정 행을 선택했을 때 호출됩니다. 보통 사용자가 선택한 내용에 맞는 액션을 처리하는 용도로 사용되죠 그러니 사용자가 행을 선택했을 때 딱히 처리해줄 액션 없이, 그저 화면에 목록을 표시하기만 하는 용도의 테이블 뷰라면 이 메소드를 구현할 필요는 없습니다. 반대로 사용자가 행을 선택했을 때 그에 맞게 화면ㅇ르 이동하던가 혹은 상세 내용을 팝업으로 보여주는 등의 다양한 기능을 구현하고 싶다면 이 메소드를 구현해 주어야 합니다. 우리는 이 메소드 내부에 원하는 로직을 작성하면 됩니다.

  ```swift
  optional func tableView(_ tableView: UITableView, 
           didSelectRowAt indexPath: IndexPath)
  ```

  - 이 메소드는 델리게이트 메소드이기 때문에 앞의 두 메소드처럼 적절한 시점에 맞추어 자동으로 호출됩니다. 차이점이 있다면 앞의 두 메소드는 테이블 뷰를 화면에 구현할 때 호출되는 데 반해 이 메소드는 사용자의 액션이 있을 때 호출된다는 점입니다.
  
  - 이때 iOS 시스템은 앞서와 마찬가지로 두 개의 인자값을 함께 전달합니다. 첫 번째 인자값이 사용자가 터치한 테이블 뷰에 대한 참조값, 그리고 두 번째 인자값이 터치된 행에 대한 정보입니다. 앞에서 설명한 데이터 소스 관련 메소드 중 두 번째 메소드와 동일한 인자값 형식이죠 이 두 가지 인자값을 이용하여 우리는 사용자가 어느 테이블 뷰의 몇 번째 행을 선택했는지를 확인할 수 있으며, 새로운 화면으로 이동하는 코드를 작성하거나 알림창, 혹은 기타 기능을 자것ㅇ하는 과정을 구현할 수도 있습니다.
  
  - 재사용 큐(Reusable Queue)는 한 차례 사용된 테이블 셀 인스턴스가 폐기되지 않고 재사용을 위해 대기하는 공간으로 만약 dequeueReusableCellWithIdentifier: 메소드가 호출되었을 때 입력된 아이디에 맞는 인스턴스가 큐에 있다면 이 인스턴스를 꺼내어 재사용하고, 만약 입력된 아이디에 맞는 인스턴스가 큐에 있다면 이 인스턴스를 꺼내어 재사용하고, 만약 입력된 아이디에 맞는 인스턴스가 큐에 없다면 새로 생성하여 제공하는 방식으로 동작
  
    >재사용 큐 : 데이터 소스 수만큼의 데이블 뷰 셀을 만들어 내는 대신 당장 현재의 화면에 표시되어야 하는 만큼만 셀을 생성해 내고 그때그때 필요에 따라 셀을 추가합니다. 이 과정에서 매번 새로운 셀을 생성하면 너무 메모리의 부담이 크기 때문에 셀 객체를 저장하는 공간을 만들어 두고 여기에 셀 객체를 저장해두었다가 필요할 때 꺼내어 사용하게 됨 필요 없어진 셀 객체는 여기에 다시 저장
    >
  
  - 입력된 인자값에 대한 프로토타입 셀이 존제하지 않을 경우를 대비해 메소드 결과값은 옵셔널 타입으로 변환
  
- cell.textLabel

  - 만약 테이블 셀의 textLabel 속성에 값이 있으면 하위 속성인 .text에 row.title 값을 대입하고, 없으면 아무것도 처리하지 않음

    >옵셔널체인 : 옵셔널로 선언된 객체를 사용할 때 매번 nil 여부를 체크해야 하는 비효율성을 줄이기 위한 문법으로, 옵셔널 타입의 객체와 그의 속성 사이에서 ? 연산자를 통해 구현됩니다. 이렇게 작성된 옵셔널 타입은 값이 있을 경우 작성된 내용을 정사적으로 실행하지만, 값이 비어 있더라도 실행을 건너뚜리 뿐 오류를 발생시키지 않습니다.

  - 주어진 셀에 textLabel 속성의 값이 있다는 것은 어떤 의미인지 생각해보자 -> 앞서 우리는 프로토타입 셀에 몇 가지 스타일 타입이 있다고 배웠음 (Basic, Subtitle...) 이들 타입은 모두 제목을 가집니다. 다시 말해 textLabel 속성에 값이 저장되어 있는 것이죠, 따라서 해당 속성을 사용하여 제목을 간단하게 홤녀에 표시할 수 있음

  - 그런데 Custom 타입에는 textLabel 속성이 정의되어 있지 않습니다. 개발자가 원하는 대로 셀을 구현하기 위해 다른 어떤 기본 텍스트 속성도 지원하지 않는 것입니다. 따라서 주어진 셀의 타입이 만약 Custom으로 설정되어 있다면 textLabel 속성에는 값이 비어있는 상태가 됩니다.  이처럼 값이 비어있을 가능성이 있는 변수는 오류 방지와 간결한 처리를 위해 옵셔널 타입으로 처리하는 것이 스위프트의 특징이라고 설명한 바 있습니다. 그래서 테이블 뷰 셀의 하위 속성인 textLabel은 옵셔널 타입으로 정의됩니다.

  - 만약 옵셔널 체인을 사용하지 않는다면 위 코드는 textLabel 속성이 있는지를 검사하기 위한 조건절이 포함되어야 하고, 이는 코드를 복잡하게 만드는 요인이 됨 반대로 말하면 옵셔널 체인 덕분에 코드를 한 줄로 작성할 수 있음

- tableView(_:numberOfRowsInSection:) : 메소드를 구현하고, 생성할 목록의 길이를 반환

- tableView(_:cellForRowAt:) : 메소드를 구현하고, 셀 객체를 생성하여 콘텐츠를 구성한 다음 반환

- tableView(_:didSelectRowAt:) : 메소드를 구현하고, 사용자가 셀을 선택했을 때 실행할 액션을 정의

- 

  

### 4. 페이블 뷰의 행 높이

#### 4 -1) 모두 동일한 높이를 갖는 방식

tableView(_:estimatedHeightForRowAt:)

- 테이블 뷰에서 특정 행의 노이를 설정하고 싶을 때 사용하는 메소드 , 모든 셀에 공통으로 적용되어 모두 동일한 높이를 갖음

#### 4 -2) 각 셀마다 다른 높이를 갖는 방식

위 함수를 이용해 indexPath.row활용

```
func tableView(_ tableView: UITableView, heightForRowAt indexPath: IndexPath) -> CGFloat {
        let row = self.detailData[indexPath.row]
        // 글의 길이가 15자가 넘어갈 때마다 40만큼 높이를 높여준다
        let height = CGFloat(30 + (row.count / 15) * 40 )
        return height
        //return CGFloat(60)
    }
```



#### 4 -3)  Self - Sizing Cell 방식

#### 내부 콘텐츠에 따라 동적으로 셀의 높이가 변하는 방식

